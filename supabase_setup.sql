-- 1. Garante que a tabela collections existe
CREATE TABLE IF NOT EXISTS public.collections (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    name TEXT NOT NULL,
    slug TEXT NOT NULL UNIQUE,
    image TEXT NOT NULL,
    description TEXT
);

-- 2. Adiciona colunas que podem estar faltando
DO $$
BEGIN
    ALTER TABLE public.collections ADD COLUMN IF NOT EXISTS image TEXT;
    ALTER TABLE public.collections ADD COLUMN IF NOT EXISTS description TEXT;
    ALTER TABLE public.collections ADD COLUMN IF NOT EXISTS slug TEXT;
EXCEPTION
    WHEN duplicate_column THEN RAISE NOTICE 'column already exists';
END $$;

-- 3. Reseta as permissões de collections
DROP POLICY IF EXISTS "Allow public read access" ON public.collections;
DROP POLICY IF EXISTS "Allow authenticated insert" ON public.collections;
DROP POLICY IF EXISTS "Allow authenticated update" ON public.collections;
DROP POLICY IF EXISTS "Allow authenticated delete" ON public.collections;

ALTER TABLE public.collections ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public read access" ON public.collections FOR SELECT USING (true);
CREATE POLICY "Allow authenticated insert" ON public.collections FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Allow authenticated update" ON public.collections FOR UPDATE USING (auth.role() = 'authenticated');
CREATE POLICY "Allow authenticated delete" ON public.collections FOR DELETE USING (auth.role() = 'authenticated');

-- Create categories table
CREATE TABLE IF NOT EXISTS public.categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    name TEXT NOT NULL UNIQUE,
    slug TEXT NOT NULL UNIQUE
);

ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
    DROP POLICY IF EXISTS "Allow public read access" ON public.categories;
    DROP POLICY IF EXISTS "Allow authenticated insert" ON public.categories;
    DROP POLICY IF EXISTS "Allow authenticated update" ON public.categories;
    DROP POLICY IF EXISTS "Allow authenticated delete" ON public.categories;

    CREATE POLICY "Allow public read access" ON public.categories FOR SELECT USING (true);
    CREATE POLICY "Allow authenticated insert" ON public.categories FOR INSERT WITH CHECK (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated update" ON public.categories FOR UPDATE USING (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated delete" ON public.categories FOR DELETE USING (auth.role() = 'authenticated');
END $$;

-- Create products table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    name TEXT NOT NULL,
    brand TEXT NOT NULL DEFAULT 'Conexão 011',
    price NUMERIC NOT NULL,
    images TEXT[] NOT NULL DEFAULT '{}',
    category TEXT NOT NULL,
    sizes JSONB NOT NULL DEFAULT '[]',
    description TEXT,
    slug TEXT NOT NULL UNIQUE,
    collection_id BIGINT REFERENCES public.collections(id) ON DELETE SET NULL,
    category_id BIGINT REFERENCES public.categories(id) ON DELETE SET NULL
);

-- Ensure products table has all columns (migration)
DO $$
BEGIN
    ALTER TABLE public.products ADD COLUMN IF NOT EXISTS category_id BIGINT REFERENCES public.categories(id) ON DELETE SET NULL;
    ALTER TABLE public.products ADD COLUMN IF NOT EXISTS sizes JSONB NOT NULL DEFAULT '[]';
EXCEPTION
    WHEN duplicate_column THEN RAISE NOTICE 'column already exists';
END $$;

-- Enable Row Level Security for products
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

-- Create policies for products
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'products' AND policyname = 'Allow public read access'
    ) THEN
        CREATE POLICY "Allow public read access" ON public.products
            FOR SELECT
            USING (true);
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'products' AND policyname = 'Allow authenticated insert'
    ) THEN
        CREATE POLICY "Allow authenticated insert" ON public.products
            FOR INSERT
            WITH CHECK (auth.role() = 'authenticated');
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'products' AND policyname = 'Allow authenticated update'
    ) THEN
        CREATE POLICY "Allow authenticated update" ON public.products
            FOR UPDATE
            USING (auth.role() = 'authenticated');
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'products' AND policyname = 'Allow authenticated delete'
    ) THEN
        CREATE POLICY "Allow authenticated delete" ON public.products
            FOR DELETE
            USING (auth.role() = 'authenticated');
    END IF;
END
$$;

-- Create clients table
CREATE TABLE IF NOT EXISTS public.clients (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    name TEXT NOT NULL,
    email TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'Ativo',
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    orders_count INTEGER DEFAULT 0
);

ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
    DROP POLICY IF EXISTS "Allow authenticated read access" ON public.clients;
    DROP POLICY IF EXISTS "Allow authenticated insert" ON public.clients;
    DROP POLICY IF EXISTS "Allow authenticated update" ON public.clients;
    DROP POLICY IF EXISTS "Allow authenticated delete" ON public.clients;

    CREATE POLICY "Allow authenticated read access" ON public.clients FOR SELECT USING (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated insert" ON public.clients FOR INSERT WITH CHECK (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated update" ON public.clients FOR UPDATE USING (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated delete" ON public.clients FOR DELETE USING (auth.role() = 'authenticated');
END $$;

-- Create orders table
CREATE TABLE IF NOT EXISTS public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    client_id BIGINT REFERENCES public.clients(id) ON DELETE SET NULL,
    client_name TEXT NOT NULL,
    client_address TEXT NOT NULL,
    items JSONB NOT NULL DEFAULT '[]',
    total NUMERIC NOT NULL DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'Pendente'
);

ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
    DROP POLICY IF EXISTS "Allow authenticated read access" ON public.orders;
    DROP POLICY IF EXISTS "Allow authenticated insert" ON public.orders;
    DROP POLICY IF EXISTS "Allow authenticated update" ON public.orders;
    DROP POLICY IF EXISTS "Allow authenticated delete" ON public.orders;

    CREATE POLICY "Allow authenticated read access" ON public.orders FOR SELECT USING (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated insert" ON public.orders FOR INSERT WITH CHECK (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated update" ON public.orders FOR UPDATE USING (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated delete" ON public.orders FOR DELETE USING (auth.role() = 'authenticated');
END $$;

-- Create store_settings table
CREATE TABLE IF NOT EXISTS public.store_settings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    store_name TEXT NOT NULL DEFAULT 'Conexão 011',
    logo TEXT,
    banner TEXT,
    primary_color TEXT NOT NULL DEFAULT '#EAB308',
    secondary_color TEXT NOT NULL DEFAULT '#000000',
    contact_email TEXT NOT NULL,
    contact_phone TEXT NOT NULL,
    address TEXT NOT NULL,
    shipping_price NUMERIC NOT NULL DEFAULT 0
);

ALTER TABLE public.store_settings ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
    DROP POLICY IF EXISTS "Allow public read access" ON public.store_settings;
    DROP POLICY IF EXISTS "Allow authenticated insert" ON public.store_settings;
    DROP POLICY IF EXISTS "Allow authenticated update" ON public.store_settings;
    DROP POLICY IF EXISTS "Allow authenticated delete" ON public.store_settings;

    CREATE POLICY "Allow public read access" ON public.store_settings FOR SELECT USING (true);
    CREATE POLICY "Allow authenticated insert" ON public.store_settings FOR INSERT WITH CHECK (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated update" ON public.store_settings FOR UPDATE USING (auth.role() = 'authenticated');
    CREATE POLICY "Allow authenticated delete" ON public.store_settings FOR DELETE USING (auth.role() = 'authenticated');
END $$;

-- Create storage bucket for images if it doesn't exist
INSERT INTO storage.buckets (id, name, public)
VALUES ('images', 'images', true)
ON CONFLICT (id) DO NOTHING;

-- Create storage policies
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'objects' AND policyname = 'Give public access to images'
    ) THEN
        CREATE POLICY "Give public access to images" ON storage.objects
            FOR SELECT
            USING (bucket_id = 'images');
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'objects' AND policyname = 'Allow authenticated uploads'
    ) THEN
        CREATE POLICY "Allow authenticated uploads" ON storage.objects
            FOR INSERT
            WITH CHECK (bucket_id = 'images' AND auth.role() = 'authenticated');
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'objects' AND policyname = 'Allow authenticated updates'
    ) THEN
        CREATE POLICY "Allow authenticated updates" ON storage.objects
            FOR UPDATE
            USING (bucket_id = 'images' AND auth.role() = 'authenticated');
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'objects' AND policyname = 'Allow authenticated deletes'
    ) THEN
        CREATE POLICY "Allow authenticated deletes" ON storage.objects
            FOR DELETE
            USING (bucket_id = 'images' AND auth.role() = 'authenticated');
    END IF;
END
$$;
